<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.83.1"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#2b5797"><meta name=theme-color content="#ffffff"><title>NES Emulator in Rust - David Tyler's Blog</title><meta name=author content="David Tyler"><meta name=description content="NES Emulator in Rust with no unsafe code and only compile time guarantees."><meta name=keywords content="emulation,rust"><meta property="og:title" content="NES Emulator in Rust"><meta name=twitter:title content="NES Emulator in Rust"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.davetcode.co.uk/post/nes-emulator-rust/"><meta property="og:description" content="NES Emulator in Rust with no unsafe code and only compile time guarantees."><meta name=twitter:description content="NES Emulator in Rust with no unsafe code and only compile time guarantees."><meta property="og:image" content="https://blog.davetcode.co.uk/space-invaders/images/space_invaders.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.davetcode.co.uk/space-invaders/images/space_invaders.png"><meta property="article:published_time" content="2020-12-10T10:09:51+00:00"><meta property="article:modified_time" content="2020-12-10T10:09:51+00:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://blog.davetcode.co.uk/assets/css/fuji.min.css></head><body data-theme=auto><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script><header><div class="container-xl clearfix"><div class="col-12 header"><a class=title-main href=https://blog.davetcode.co.uk/>David Tyler's Blog</a>
<span class=title-sub>Technical writing mostly focused on emulating old systems.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://blog.davetcode.co.uk/post/nes-emulator-rust/>NES Emulator in Rust</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-12-10</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2438 words</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;12 minutes</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/emulation>emulation</a>&nbsp;<a href=/tags/rust>rust</a>&nbsp;</span></div><div class="post-content markdown-body"><p>Over a period of 2 months in 2020 I intermittently worked on a NES emulator in rust to build a proper opinion of the language (and because it&rsquo;s fun). On the whole it was quite successful, <a href=https://github.com/DaveTCode/nes-emulator-rust>https://github.com/DaveTCode/nes-emulator-rust</a> now exists, has coverage of maybe 80% of the total ROM dumps out there, and passes almost all of the <a href=https://wiki.nesdev.com/w/index.php/Emulator_tests target=_blank>test rom suite</a>.</p><p>All achieved with no <code>unsafe</code>, no <code>Rc</code>/<code>Refcell</code>, minimal heap allocations (we don&rsquo;t know how big a Rom is at compile time, it might be 8KB or 256KB) and a small handful of external crates.</p><p>This blog post is a write up of my feelings around rust as a language but probably provides some insights into writing an emulator along the way. I&rsquo;m not claiming any level of expertise as a rust developer and only marginally more as an emulator developer!</p><table><tr><td style=width:200px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/ninja-gaiden.png alt="Ninja Gaiden"></div></p></td><td style=width:200px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/mario.png alt=Mario></div></p></td><td style=width:200px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/zelda.png alt=Zelda></div></p></td><td style=width:200px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/battletoads.png alt=Battletoads></div></p></td><td style=width:200px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/metalgear.png alt=Metalgear></div></p></td></tr></table><p>TL;DR
This is quite long. Broad summary was that I was pleasantly surprised with all the bits surrounding the language (tooling, IDE support etc) and I liked the WIBNI style language features I found but that my key takeaway was that moreso than other languages, you need more up front knowledge both of rust and the domain you&rsquo;re working in to produce high quality code. I don&rsquo;t know if that&rsquo;s controversial, you&rsquo;ll have to read on if you think I&rsquo;m wrong!</p><h2 id=language>Language</h2><h3 id=the-good>The good</h3><p>There was an awful lot to like about rust as a core language, I&rsquo;ve listed some of those that really stood out here but on the whole I almost never felt let down by writing code that would be more readable/beautiful if I only had feature X. The only really notable example is that <a href=https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html>https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html</a> in stable would have allowed me to write a CPU state machine with the language managing state instead of me doing it. That&rsquo;s fine, it&rsquo;s coming along in the future.</p><ol><li><p>wrapping_add & saturating_add + panics when you over/underflow in non-release builds was an absolute life saver. Emulators of 8 bit computers spend a ton of time working with 8 bit integers (and 16 bit for some of the addresses), being forced to behave myself about when I want to wrap, saturate or not was really valuable. The extra overhead is a problem in an emulator but knowing I&rsquo;ll get a panic when I deliberately revert to explicit addition if I&rsquo;m wrong about my invariants caught at least half a dozen bugs
e.g. <a href=https://github.com/DaveTCode/nes-emulator-rust/blob/master/src/cpu/mod.rs#L1031>https://github.com/DaveTCode/nes-emulator-rust/blob/master/src/cpu/mod.rs#L1031</a> is fine because I know that a DMA address will only ever run for 0xFF bytes, whereas <a href=https://github.com/DaveTCode/nes-emulator-rust/blob/master/src/cpu/mod.rs#L135>https://github.com/DaveTCode/nes-emulator-rust/blob/master/src/cpu/mod.rs#L135</a> increments the PC by 1, which CAN wrap around the address space and so wrapping_add.</p></li><li><p>Match statements are as mature as anything I&rsquo;ve seen and I massively abused them throughout</p><ul><li>The below is just kinda gorgeous code compared to the if statement equivalent. Nothing particularly new to me coming from C# but most other modern languages don&rsquo;t have them and they are fuller featured here anyway,</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>match</span> address {  
    <span style=color:#ae81ff>0x0000</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x1FFF</span> <span style=color:#f92672>=&gt;</span> self.ram[(address <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x7FF</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>],
    <span style=color:#ae81ff>0x2000</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x2007</span> <span style=color:#f92672>=&gt;</span> self.ppu.read_register(address),
    <span style=color:#ae81ff>0x2008</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x3FFF</span> <span style=color:#f92672>=&gt;</span> self.ppu.read_register((address <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x2000</span>),
    <span style=color:#ae81ff>0x4000</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x4013</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>0x4015</span> <span style=color:#f92672>=&gt;</span> self.apu.read_byte(address), <span style=color:#75715e>// APU registers
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x4014</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// TODO - Is this correct? We read 0 on the DMA register?
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x4016</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x4017</span> <span style=color:#f92672>=&gt;</span> self.io.read_byte(address), <span style=color:#75715e>// Controller registers
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x4018</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0x401F</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// TODO - Unused APU &amp; IO registers
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x4020</span>..<span style=color:#f92672>=</span><span style=color:#ae81ff>0xFFFF</span> <span style=color:#f92672>=&gt;</span> self.prg_address_bus.read_byte(address),
}
</code></pre></div><ul><li>I was a bit disappointed with if let matching and the inability to chain <code>if let Some(x) && x == something</code>, nice to have a couple of little pointless things to grumble about though.</li></ul></li><li><p>Number formatting is honestly necessary in an emulator, deconstructing a value into bit fields with _ spaced sections is something I would get really annoyed without</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>self.internal_registers.temp_vram_addr <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0b0000_0100_0001_1111</span>
</code></pre></div></li><li><p>Macros seem really cool but I&rsquo;m still scared of them after C. I made one standard (and quite nice) use in <a href=https://github.com/DaveTCode/nes-emulator-rust/blob/master/tests/test_roms.rs>https://github.com/DaveTCode/nes-emulator-rust/blob/master/tests/test_roms.rs</a> to construct parameterised tests but I feel like if I really got them then I could rewrite the CPU using macros instead of a state machine and the end result would have been more readable and most likely notably more performant.</p></li><li><p>Proper discriminated unions are something I&rsquo;ve harped on at people about before (C# doesn&rsquo;t have them although F# does), I made pretty solid use of them in various bits of this emulator. Particularly for building a sprite fetch state machine but there&rsquo;s lots of other use cases as well:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[derive(Debug, Copy, Clone)]</span>
<span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>SpriteEvaluation</span> {
  ReadY,
  WriteY { y: <span style=color:#66d9ef>u8</span> },
  ReadByte { count: <span style=color:#66d9ef>u8</span> },
  WriteByte { count: <span style=color:#66d9ef>u8</span>, value: <span style=color:#66d9ef>u8</span> },
  Completed,
}
</code></pre></div></li></ol><h3 id=the-unsure>The unsure</h3><p>Traits & structs vs interfaces & objects never really clicked with me but I think it&rsquo;s probably just a case of a paradigm shift that I haven&rsquo;t fully acclimatised to yet. The key example in a NES emulator is mappers. A front loading NES has a cartridge slot that you plug the game cartridge into, there are various address lines attached to it but basically it breaks down to two interfaces:</p><ol><li>A 16bit wide address bus to the CPU</li><li>A 14bit wide addess bus to the PPU (side note, wouldn&rsquo;t it be great if languages could allow for arbitrary width integers with corresponding wrapping_add etc)</li></ol><p>A natural way to model a cartridge in an inheritance & interface based language might be:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>interface CpuAddressBus {
  read_byte(address: <span style=color:#66d9ef>u16</span>, cycle: <span style=color:#a6e22e>CpuCycle</span>) -&gt; <span style=color:#66d9ef>u8</span>;
  write_byte(address: <span style=color:#66d9ef>u16</span>, value: <span style=color:#66d9ef>u8</span>, cycle: <span style=color:#a6e22e>CpuCycle</span>);
}
 
<span style=color:#66d9ef>abstract</span> class CpuCartridge : <span style=color:#a6e22e>CpuAddressBus</span> {
  rom: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>;
 
  read_byte(address) ... blah
}
</code></pre></div><p>Then crucially, when you find that there&rsquo;s a mapper which blocks writes on consecutive cycles you can extend that base class with an extra field tracking last_write_cycle using inheritance and overwrite the write_byte function. My implementation of this in rust required a trait for the CpuAddressBus, a base structure and then composition to put that base structure into MyMapper, that means you awkwardly end up writing passthrough functions all over the place</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_byte</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, address: <span style=color:#66d9ef>u16</span>, _: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u8</span> {
  self.base.read_byte(address)
}
</code></pre></div><p>which feels a bit crap.</p><p>The whole <a href=https://github.com/DaveTCode/nes-emulator-rust/tree/master/emulator/src/cartridge target=_blank>mapper section of my code base</a> is probably one of the key ones where I&rsquo;d like a code review from an experienced rustacean, I&rsquo;m not at all committed to this being a problem with the language. It smells much more like a problem with me!</p><h3 id=the-bad>The bad(?)</h3><p>I (wrongly) set out with the intention of building an emulator which didn&rsquo;t break out of the core rust safety model using runtime checks or unsafe blocks. As a consequence I spent a very long time trying to work out how to model an emulator in rust and I&rsquo;ve ended up writing something in which data flow is far harder to reason about than I would have if I&rsquo;d been allowed multiple mutable references & circular references.</p><p>Consider the following diagram showing some elements of the NES</p><img src=../../nes-emulator-rust/images/ideal_architecture.png height=250><p>Here the CPU needs mutable access to the cartridge (cartidge hosts RAM) and the PPU also needs mutable access to the cartridge. The CPU also needs mutable access to the PPU (set PPU data like palette information) but the PPU might trigger an NMI (non-maskable interrupt) to tell the CPU something. In my <a href=https://github.com/DaveTCode/gameboy-emulator-dotnet target=_blank>gameboy emulator (C#)</a> I can model this domain exactly as above, everything has mutable references to everything else (roughly) and whilst that is less robust to future developers making mistakes it&rsquo;s a closer model of the actual data domain in which I&rsquo;m working.</p><p>In (safe, compile time checked) Rust the above has two key problems forcing me to create something a bit weird, less performant and harder to reason about:</p><ol><li>The cartridge is owned by two objects (CPU & PPU both read/write to the cartridge)<ul><li>This was almost fun, cartridges have multiple components so I split the cartridge into a <code>Box&lt;dyn PpuAddressBus></code> and a <code>Box&lt;dyn CpuAddressBus></code>. Unfortunately there&rsquo;s still some address lines which can mutate state on both. So very sadly I end up duplicating all writes from the CPU into both cartridge spaces (this isn&rsquo;t as big a perf deal as you&rsquo;d think, 99.9% of the time the write is ignored on one or other cartridge)</li></ul></li><li>There are cycles between the CPU and components which fire interrupts (PPU, APU & Cartridge)<ul><li>This was really ugly, I end up having to poll for interrupts from the CPU to each of the components, that in itself has probably caused literal days of pain handling subtle timing issues of when the poll occurs in relation to the write which caused the interrupt. All because I can&rsquo;t have a reference cycle.</li></ul></li></ol><p>The end result looks something like this:</p><img src=../../nes-emulator-rust/images/actual_architecture.png height=250><p>What&rsquo;s my conclusion here? Is rust bad for my particular problem domain? Kind of yes and kind of no. A more experienced rust developer would have taken one look at the domain and said &ldquo;yep, I need to use <code>Rc&lt;RefCell&lt;>></code>&rdquo; and not even tried to do what I did. I didn&rsquo;t feel qualified to make that call at the start and crucially it would be a collosal PITA to refactor the whole domain at a late point in the project. In another language you would have expected to model the domain exactly and if you got it wrong you&rsquo;d have been in a much better place to reorganise your code.</p><p>I think what that really drove home for me is that architecting code in rust is notably harder than architecting it in another language, your choices are more limited, you will quite easily dig yourself a hole you can&rsquo;t easily get out of (I nearly threw the whole thing away when I realised that Cartridges could fire IRQs (they only can on certain &ldquo;mappers&rdquo; so it was quite late into the project that I noticed)). Maybe this is controversial?</p><h2 id=development-environment>Development Environment</h2><h3 id=tooling>Tooling</h3><p>The overall tooling for rust is obviously absolutely incredible, I don&rsquo;t care which language you come from there&rsquo;s nothing out there that can beat it. rustfmt, clippy, cargo bench, workspaces, cargo flamegraph, dependabot support etc etc. With the notable exception of code coverage there was really nothing that I felt like I was missing and crucially none of it was utterly bollocks unlike certain other languages. The documentation on how to use various features was excellent as well.</p><p>Good job everyone involved in making rust not annoying to work with!</p><h3 id=idedebugger>IDE/Debugger</h3><p>I exclusively work in windows and have a very strong preference for a development environment with interactive debugger, integrated test results, one click to run various different invocations of the program etc. I started off with vscode but found the code completion and debugging support in Windows to be atrocious (failed to start sometimes, hit errors other times, breakpoints didn&rsquo;t work intermittently, ability to inspect state on a breakpoint was flaky) so switched to CLion (Jetbrains C++ IDE with rust support). Fortunately that was excellent, paired with the visual studio toolchain and bundled LLDB I got something quite similar to the IDE experience I&rsquo;m used to writing python/C#/java. Clippy warnings and proposed fixes inline, rustfmt on save, automatic macro expansion, step through debugging with variable inspection.</p><p>I did have some issues after migrating the application into workspaces, occasional hangs whilst running background analysis processes and some fun guessing how to tell CLion what the invocation is to debug a binary but nothing insurmountable.</p><table><tr><td style=width:50%><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/test_results.png alt="Test Results"></div></p></td><td style=width:50%><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/clippy.png alt=Clippy></div></p></td></tr></table><h3 id=profiling>Profiling</h3><p>Another thing I thought I would miss from visual studio c# coding was profiling tools, the profiling tools for dotnet are absolutely first class and I was expecting to run into the &ldquo;oh, just use this arcane C thing but make sure you have the right symbols loaded and you&rsquo;re using this exact version of blah&rdquo;. Fortunately not true (smile). I was unable to cargo flamegraph due to dtrace requirements (c.f. <a href=https://techcommunity.microsoft.com/t5/Windows-Kernel-Internals/DTrace-on-Windows/ba-p/362902>https://techcommunity.microsoft.com/t5/Windows-Kernel-Internals/DTrace-on-Windows/ba-p/362902</a> - it&rsquo;s coming but only insider builds of windows at the moment). However, because I was building for windows with the toolchain stable-x86_64-pc-windows-msvc I was able to attached visual studio to the process and get a really nice output like I&rsquo;d expect.</p><table><tr><td style=width:50%;height:250px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/flamegraph.png alt=Flamegraph></div></p></td><td style=width:50%;height:250px><p><div class="image-wrapper ratio-1x1"><img class="lazyload img-zoomable" data-src=/nes-emulator-rust/images/coverage.png alt=Coverage></div></p></td></tr></table><p>Enough to fix my stupid &ldquo;oh yeah, constructing strings for logging is expensive I remember&rdquo; issue at any rate (wink)</p><h3 id=cicd>CI/CD</h3><p>Emulators are incredibly finicky beasts, tweaking things to fix one issue will often break several tests that relied on precise timings elsewhere. So automated testing is basically a necessity. I wasn&rsquo;t sure what sort of support I&rsquo;d get in Azure DevOps for rust but I was at least able to get it building on nightly, mac, windows and linux on each commit along with parsing test results. I normally like to get code coverage stats as well but it seemed less trivial than I&rsquo;d hoped and I haven&rsquo;t yet got around to it. Definitely not insurmountable and I&rsquo;ve seen posts floating that suggest this&rsquo;ll be trivial in the future.</p><img src=../../nes-emulator-rust/images/ci.png height=test_results><p>I found <a href=https://github.com/crate-ci/azure-pipelines>https://github.com/crate-ci/azure-pipelines</a> after writing my pipeline based on blog articles and it looks to be a much more comprehensive set of ideas. So nobody should be looking at what I did for ideas, just noting that a beginner in both ADO and rust was able to get up and running with minimal fuss!</p><h2 id=conclusion>Conclusion</h2><p><strong>&ldquo;Rust restricts how you model your domain, and I&rsquo;m not sure that&rsquo;s necessarily a good thing&rdquo;</strong></p><p>A good principle to remember when considering coding arguments is &ldquo;my problems are not necessarily your problems&rdquo;. I think all senior engineers understand this at some point. When you find yourself inclined to argue about coding issues: &ldquo;unit tests vs integration tests&rdquo;, &ldquo;dynamic vs static typing&rdquo;, &ldquo;short functions vs long function&rdquo; or any other absurd thing that you can bait people with then I think this is a great mantra to remember. Not all domains are equal, someone working on websites has a very different outlook to someone writing FPGA code to someone writing games. Typically similar problems exist in all these environments but the value functions applied to determine how and whether to solve them are different.</p><p>8 bit Emulators as a domain are quite interesting, they require no(ish) dynamically allocated memory, have very stringent performance requirements whilst being incredibly poorly suited to concurrency and have an exceptionally well defined end point. So taking as an example, Rust cares very deeply about data ownership which helps make sure that concurrent code is safe. Great! &ldquo;Your problems are not my problems&rdquo;.</p><p>So most of rusts restrictiveness of structure is unnecessary in an emulator environment. Therefore, when it encourages a poor domain model it feels like a bad trade off. Now, that said, it&rsquo;s clear that the correct domain model is viable if you know how to make proper use of <a href=https://doc.rust-lang.org/1.15.1/book/choosing-your-guarantees.html>https://doc.rust-lang.org/1.15.1/book/choosing-your-guarantees.html</a>. So my real conclusion is that rust forces an up front decision which only experienced rust developers who fully understand the domain they&rsquo;re about to model can get right.</p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/davetcode target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/datyler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/8080/>8080</a></span>
<span><a href=/tags/clr/>clr</a></span>
<span><a href=/tags/csharp/>csharp</a></span>
<span><a href=/tags/emulation/>emulation</a></span>
<span><a href=/tags/rust/>rust</a></span>
<span><a href=/tags/satire/>satire</a></span>
<span><a href=/tags/spaceinvaders/>spaceinvaders</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#language>Language</a><ul><li><a href=#the-good>The good</a></li><li><a href=#the-unsure>The unsure</a></li><li><a href=#the-bad>The bad(?)</a></li></ul></li><li><a href=#development-environment>Development Environment</a><ul><li><a href=#tooling>Tooling</a></li><li><a href=#idedebugger>IDE/Debugger</a></li><li><a href=#profiling>Profiling</a></li><li><a href=#cicd>CI/CD</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/davetcode target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/datyler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/8080/>8080</a></span>
<span><a href=/tags/clr/>clr</a></span>
<span><a href=/tags/csharp/>csharp</a></span>
<span><a href=/tags/emulation/>emulation</a></span>
<span><a href=/tags/rust/>rust</a></span>
<span><a href=/tags/satire/>satire</a></span>
<span><a href=/tags/spaceinvaders/>spaceinvaders</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#language>Language</a><ul><li><a href=#the-good>The good</a></li><li><a href=#the-unsure>The unsure</a></li><li><a href=#the-bad>The bad(?)</a></li></ul></li><li><a href=#development-environment>Development Environment</a><ul><li><a href=#tooling>Tooling</a></li><li><a href=#idedebugger>IDE/Debugger</a></li><li><a href=#profiling>Profiling</a></li><li><a href=#cicd>CI/CD</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2021-2021
<a href=https://blog.davetcode.co.uk/>David Tyler</a>
| <a href=https://github.com/davetcode>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script></body></html>