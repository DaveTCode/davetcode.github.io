<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.83.1"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#2b5797"><meta name=theme-color content="#ffffff"><title>Experiments in 8080 static/jit compilation - David Tyler's Blog</title><meta name=author content="David Tyler"><meta name=description content="An 8080 emulator JIT compiled into CLR IL"><meta name=keywords content="emulation,8080,csharp,clr"><meta property="og:title" content="Experiments in 8080 static/jit compilation"><meta name=twitter:title content="Experiments in 8080 static/jit compilation"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.davetcode.co.uk/post/jit-8080/"><meta property="og:description" content="An 8080 emulator JIT compiled into CLR IL"><meta name=twitter:description content="An 8080 emulator JIT compiled into CLR IL"><meta property="og:image" content="https://blog.davetcode.co.uk/space-invaders/images/space_invaders.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.davetcode.co.uk/space-invaders/images/space_invaders.png"><meta property="article:published_time" content="2021-01-15T13:33:09+00:00"><meta property="article:modified_time" content="2021-01-15T13:33:09+00:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://blog.davetcode.co.uk/assets/css/fuji.min.css></head><body data-theme=auto><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script><header><div class="container-xl clearfix"><div class="col-12 header"><a class=title-main href=https://blog.davetcode.co.uk/>David Tyler's Blog</a>
<span class=title-sub>Technical writing mostly focused on emulating old systems.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://blog.davetcode.co.uk/post/jit-8080/>Experiments in 8080 static/jit compilation</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-01-15</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2331 words</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;11 minutes</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/emulation>emulation</a>&nbsp;<a href=/tags/8080>8080</a>&nbsp;<a href=/tags/csharp>csharp</a>&nbsp;<a href=/tags/clr>clr</a>&nbsp;</span></div><div class="post-content markdown-body"><p>I&rsquo;ve spent a lot of spare time over the last few years playing with emulating old computer architectures. I also spend my day job mentoring (and even occasionally writing) C#.
This project combines those two areas of interest and asks the question: &ldquo;Is it possible to recompile 8080 assembly into CLR IL&rdquo;</p><p>Did it work? Yes! I have successfully built a <a href=https://github.com/DaveTCode/8080JIT target=_blank>fully functional Space Invaders emulator with the 8080 cpu core purely implemented in IL</a>.</p><img src=../../space-invaders/images/space_invaders.png width=300><p>This blog post covers some of the details of what 8080 assembly looks like, what IL looks like, the process of mapping one to the other and also a fair bit of details about the complications involved.</p><h2 id=8080-architecture>8080 Architecture</h2><p>To start we need an understand of what an 8080 actually <em>is</em>. Interally the 8080 is a processor with the 7 8 bit registers, 5 flags, a 16 bit stack pointer, and a 16 bit program counter.</p><table><thead><tr><th>Registers</th><th>Flags</th></tr></thead><tbody><tr><td>A (accumulator)</td><td>Carry flag (did the last result carry 255 + 1 = 0 w/carry 0-1=255 w/carry)</td></tr><tr><td>B</td><td>Sign flag (was the result of the last operation twos complement negative?)</td></tr><tr><td>C</td><td>Zero flag (was the result of the last operation zero?)</td></tr><tr><td>D</td><td>Parity flag (did the last result have even <a href=https://en.wikipedia.org/wiki/Parity_flag target=_blank>parity</a> or odd parity?)</td></tr><tr><td>E</td><td>Aux Carry flag (c.f. <a href=https://en.wikipedia.org/wiki/Adjust_flag>https://en.wikipedia.org/wiki/Adjust_flag</a>)</td></tr><tr><td>H</td><td></td></tr><tr><td>L</td><td></td></tr></tbody></table><p>Externally, treated as a black box, it&rsquo;s quite a simple architecture with the following inputs & outputs:</p><ol><li>A 16 bit address bus which can have lines hooked up to anything from raw memory, to memory mapped IO devices.<ul><li>That is, whilst the CPU can only reference addresses from 0x0000-0xFFFF there&rsquo;s no guarantees whatsoever that addresses refer to R/W memory. One could be hooked up to an LED and writing to it changes the color of the LED, the next could not be wired up at all etc.</li></ul></li><li>Up to 255 IN/OUT ports which can be hooked up to any devices the designers selected (sound chips, serial ports, dedicated hardware for mathematical operations, etc)</li><li>A single interrupt line from which the external architecture can say &ldquo;jump to start executing at address X&rdquo; where X is one of a pre-defined set of 8 addresses</li></ol><img src=../../space-invaders/images/8080.png><p><em>Note: It&rsquo;s obviously a lot more complicated than that in detail, this high level view is sufficient for our emulation!</em></p><h3 id=8080-assembly>8080 Assembly</h3><p>With that context in mind we can look at what a simple piece of 8080 assembly code looks like both in textual form and in assembled bytes. The 8080 provides 255 different operations that it can perform. These generally characterise as:</p><ul><li>8 bit arithmetic<ul><li>e.g. ADI $ => register A = A + $ (the next byte) and set all the flags</li><li>CMP B => Check value of A - B and set all flags (but don&rsquo;t actually change A)</li></ul></li><li>16 bit arithmetic<ul><li>e.g. INX B => BC = BC + 1</li></ul></li><li>8 bit load/store<ul><li>e.g. LDA a16 => Get whatever is at memory address a16 and put it in A</li><li>MVI E,d8 => Put the next byte into E</li></ul></li><li>Jumps/Calls<ul><li>e.g. JZ $addr => Jump immediately to the fixed 16 bit address $addr if and only if the zero flag is set</li><li>CNC $addr => Push next instruction to stack and then jump to $addr if and only if the carry flag is not set</li><li>RET => Return to the address referred to by the top two bytes of the stack</li><li>PCHL => Set the program counter to the value of the HL register pair (dynamic jump)</li></ul></li><li>Misc<ul><li>e.g. NOP => Do nothing</li><li>HLT => Stop cpu</li></ul></li></ul><p>Code like this will get assembled from something like (taken from <a href=https://en.wikipedia.org/wiki/Intel_8080#Example_code):>https://en.wikipedia.org/wiki/Intel_8080#Example_code):</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>            <span style=color:#a6e22e>mov</span>     <span style=color:#66d9ef>a</span>,<span style=color:#66d9ef>b</span>         <span style=color:#75715e>;Copy register B to register A
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>ora</span>     <span style=color:#66d9ef>c</span>           <span style=color:#75715e>;Bitwise OR of A and C into register A
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>rz</span>                  <span style=color:#75715e>;Return if the zero-flag is set high.
</span><span style=color:#75715e></span><span style=color:#66d9ef>loop</span>:       <span style=color:#66d9ef>ldax</span>    <span style=color:#66d9ef>d</span>           <span style=color:#75715e>;Load A from the address pointed by DE
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>mov</span>     <span style=color:#66d9ef>m</span>,<span style=color:#66d9ef>a</span>         <span style=color:#75715e>;Store A into the address pointed by HL
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>inx</span>     <span style=color:#66d9ef>d</span>           <span style=color:#75715e>;Increment DE
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>inx</span>     <span style=color:#66d9ef>h</span>           <span style=color:#75715e>;Increment HL
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>dcx</span>     <span style=color:#66d9ef>b</span>           <span style=color:#75715e>;Decrement BC   (does not affect Flags)
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>mov</span>     <span style=color:#66d9ef>a</span>,<span style=color:#66d9ef>b</span>         <span style=color:#75715e>;Copy B to A    (so as to compare BC with zero)
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>ora</span>     <span style=color:#66d9ef>c</span>           <span style=color:#75715e>;A = A | C      (set zero)
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>jnz</span>     <span style=color:#66d9ef>loop</span>        <span style=color:#75715e>;Jump to &#39;loop:&#39; if the zero-flag is not set.   
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>ret</span>                 <span style=color:#75715e>;Return
</span></code></pre></div><p>to the bytes <code>78 B1 C8 1A 77 13 23 0B 78 B1 C2 03 10 C9</code> where the byte 0x78 literally means &ldquo;MOV A,B&rdquo; or &ldquo;Move the value in register B into A&rdquo;.</p><p>So an emulators job is to take that stream of bytes and pretend to be the cpu by performing each operation in turn. A typical basic emulator of old 8 bit architectures would look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
{
  <span style=color:#66d9ef>byte</span> instruction = <span style=color:#ae81ff>_</span>memoryBus.ReadByte(<span style=color:#ae81ff>_</span>programCounter);
  <span style=color:#ae81ff>_</span>programCounter++;

  <span style=color:#66d9ef>switch</span> (instruction)
  {
    ...
    <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x78</span>: <span style=color:#75715e>// MOV A, B
</span><span style=color:#75715e></span>      <span style=color:#ae81ff>_</span>registers.A = <span style=color:#ae81ff>_</span>registers.B;
      <span style=color:#66d9ef>break</span>;
    ...
  }  
}
</code></pre></div><p>A lot less hard than it sounds! Some opcodes are naturally a bit more complex to write than that but that&rsquo;s the principle.</p><h2 id=clr-il-background>CLR IL background</h2><p>Ok, so that&rsquo;s the basics of an 8080, now lets take a look at the basic building blocks of the CLR IL and see where we can draw comparisons.</p><p>There are two major steps to get any dotnet application to actually run.</p><ol><li>Compilation</li><li>Runtime JIT</li></ol><p>When you write C# and do <code>dotnet build</code> the output is normally an intermediary format which is interpreted by the runtime. So what does that intermediate format look like? In steps <a href=https://github.com/pjbgf/dotnet-ildasm target=_blank>dotnet-ildasm</a></p><p>Consider the following class</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Emulator</span>
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>byte</span> H;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>byte</span> L;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>ushort</span> HL
        {
            <span style=color:#66d9ef>get</span> =&gt; (<span style=color:#66d9ef>ushort</span>)((H &lt;&lt; <span style=color:#ae81ff>8</span>) | L);
            <span style=color:#66d9ef>set</span>
            {
                L = (<span style=color:#66d9ef>byte</span>)<span style=color:#66d9ef>value</span>;
                H = (<span style=color:#66d9ef>byte</span>)(<span style=color:#66d9ef>value</span> &gt;&gt; <span style=color:#ae81ff>8</span>);
            }
        }
    }
</code></pre></div><p>Lets build it with <code>dotnet build</code> and then run <code>dotnet ildasm assembly.dll</code> to see what we get (I&rsquo;ve removed everything except the get_HL method)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>  <span style=color:#a6e22e>.method</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>hidebysig</span> <span style=color:#66d9ef>specialname</span> <span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>uint16</span> <span style=color:#66d9ef>get_HL</span>() <span style=color:#66d9ef>cil</span> <span style=color:#66d9ef>managed</span>
  <span style=color:#960050;background-color:#1e0010>{</span>
    <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#a6e22e>Method</span> <span style=color:#66d9ef>begins</span> <span style=color:#66d9ef>at</span> <span style=color:#66d9ef>Relative</span> <span style=color:#66d9ef>Virtual</span> <span style=color:#66d9ef>Address</span> (<span style=color:#66d9ef>RVA</span>) <span style=color:#ae81ff>0x2050</span>
    <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#a6e22e>Code</span> <span style=color:#66d9ef>size</span> <span style=color:#ae81ff>17</span> (<span style=color:#ae81ff>0x11</span>)
    <span style=color:#a6e22e>.maxstack</span> <span style=color:#ae81ff>8</span>
    IL_0000: <span style=color:#a6e22e>ldarg.0</span>
    IL_0001: <span style=color:#a6e22e>ldfld</span> <span style=color:#66d9ef>byte</span> <span style=color:#66d9ef>TestILAddFields.Emulator</span>::<span style=color:#66d9ef>H</span>
    IL_0006: <span style=color:#a6e22e>ldc.i4.8</span>
    IL_0007: <span style=color:#a6e22e>shl</span>
    IL_0008: <span style=color:#a6e22e>ldarg.0</span>
    IL_0009: <span style=color:#a6e22e>ldfld</span> <span style=color:#66d9ef>byte</span> <span style=color:#66d9ef>TestILAddFields.Emulator</span>::<span style=color:#66d9ef>L</span>
    IL_000e: <span style=color:#a6e22e>or</span>
    IL_000f: <span style=color:#a6e22e>conv.u2</span>
    IL_0010: <span style=color:#a6e22e>ret</span>
  <span style=color:#960050;background-color:#1e0010>}</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#a6e22e>End</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>method</span> <span style=color:#66d9ef>System.UInt16</span> <span style=color:#66d9ef>TestILAddFields.Emulator</span>::<span style=color:#66d9ef>get_HL</span>()
</code></pre></div><p>I reckon if you squint a bit then that doesn&rsquo;t look <em>miles</em> different from the 8080 assembly in the previous section does it. Consider what it does with some commenting:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>IL_0000: <span style=color:#a6e22e>ldarg.0</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>Load</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>this</span><span style=color:#960050;background-color:#1e0010>&#34;</span> <span style=color:#66d9ef>so</span> <span style=color:#66d9ef>that</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>next</span> <span style=color:#66d9ef>variable</span> <span style=color:#66d9ef>can</span> <span style=color:#66d9ef>be</span> <span style=color:#66d9ef>loaded</span> <span style=color:#66d9ef>from</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>right</span> <span style=color:#66d9ef>class</span>
IL_0001: <span style=color:#a6e22e>ldfld</span> <span style=color:#66d9ef>byte</span> <span style=color:#66d9ef>TestILAddFields.Emulator</span>::<span style=color:#66d9ef>H</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>Load</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>value</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>H</span> <span style=color:#66d9ef>onto</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>
IL_0006: <span style=color:#a6e22e>ldc.i4.8</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>Load</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>value</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>&#34;</span> <span style=color:#66d9ef>onto</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>
IL_0007: <span style=color:#a6e22e>shl</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>Take</span> <span style=color:#66d9ef>H</span> <span style=color:#66d9ef>back</span> <span style=color:#66d9ef>off</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>, <span style=color:#66d9ef>take</span> <span style=color:#ae81ff>8</span> <span style=color:#66d9ef>off</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>, <span style=color:#66d9ef>shift</span> <span style=color:#66d9ef>H</span> <span style=color:#66d9ef>left</span> <span style=color:#66d9ef>by</span> <span style=color:#ae81ff>8</span> (<span style=color:#66d9ef>H</span> <span style=color:#960050;background-color:#1e0010>&lt;&lt;</span> <span style=color:#ae81ff>8</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>csharp</span> <span style=color:#66d9ef>code</span> <span style=color:#66d9ef>above</span>) <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>put</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>result</span> <span style=color:#66d9ef>back</span> <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>the</span> <span style=color:#66d9ef>stack</span>
</code></pre></div><p>So what are the big differences in architecture between this model and the 8080? Well, the crucial one is that the CLR uses a stack based execution model instead of registers. That is, if I want to add two numbers in 8080, I put one into A, one into another register (say C) and then call ADD C which puts the result back in A. If I want to add two numbers in CLR I push both onto the stack, call OpCodes.Add and then the result is back on the stack.</p><p>What else is different?</p><ul><li>The CLR doesn&rsquo;t have the concept of flags, whilst there are Beq (branch equal), Blt (branch less than) etc style operations there&rsquo;s no concept of carrying around persistent state about whether the last operation resulted in zero.</li><li>The CLR doesn&rsquo;t have the notion of a program counter which can be directly affected by operations, that is, you can&rsquo;t dynamically at runtime say &ldquo;now run instruction at address X&rdquo; (where X is dynamically calculated)</li></ul><h2 id=implementation>Implementation</h2><p>OK, that&rsquo;s a crap ton of background to make sure we&rsquo;re all talking the same language. How did I take all of that and create an emulator?</p><h3 id=step-1---dynamically-construct-a-class-which-looks-like-the-8080-cpu>Step 1 - Dynamically construct a class which looks like the 8080 CPU</h3><p>Here I have a single static function <code>CreateEmulator(byte[] rom)</code> which returns a dynamically created type shaped like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cpu8080</span>
{
  <span style=color:#66d9ef>byte</span> A, B, C, D, E, H, L;
  <span style=color:#66d9ef>ushort</span> StackPointer;
  <span style=color:#66d9ef>bool</span> Carry, Sign, Zero, Parity, AuxCarry;

  Run() {}
}
</code></pre></div><p>Internally that&rsquo;s done by making use of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder?view=net-5.0" target=_blank>AssemblyBuilder</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.typebuilder?view=net-5.0" target=_blank>TypeBuilder</a> etc.</p><p>We&rsquo;ll deal with how the <code>Run</code> method was generated in a bit.</p><h3 id=step-2---hook-in-all-the-external-interfaces>Step 2 - Hook in all the external interfaces</h3><p>What about memory access? Or access to arbitrary IN/OUT ports? Or providing hooks back so that the overarching computer can decide to render the screen?</p><p>For this I pass in interfaces to the various architectural interfaces. So there&rsquo;s an IMemoryBus which provides a <code>ReadByte</code> and <code>WriteByte</code> function that the CPU can call but is implemented by the calling code. Likewise for IN/OUT theres an IIOHandler with In & Out functions.</p><h3 id=step-3---recompile-the-rom-to-generate-the-run-function>Step 3 - Recompile the ROM to generate the Run function</h3><p>The meat of the smarts here are in how we take the <code>byte[]</code> that corresponds to the ROM and turn it into C# IL. That process works as follows:</p><ol><li>Create an ILGenerator for the Run method</li><li>Define labels for every instruction (so 0xFFFF labels corresponding to all the memory addresses)</li><li>Starting at 0x0000 looping until we&rsquo;ve checked all possible addresses<ul><li>Decode the operation (is it NOP, LXI, JMP etc)</li><li>Emit the label corresponding to the current program counter (so we can jump to it as needed)</li><li>Emit equivalent IL for what that instruction is trying to do</li><li>Go to the next instruction (might not be adjacent if the operation consumed more than 1 byte)</li></ul></li><li>Start the process in 3 again from the first &ldquo;not yet seen&rdquo; address until we&rsquo;ve visited all addresses</li></ol><p>Example (OUT instruction)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>methodIL.Emit(OpCodes.Ldarg_0);
methodIL.Emit(OpCodes.Ldfld, internals.IOHandlerField); <span style=color:#75715e>// This is the IIOHandler field referring to some external object
</span><span style=color:#75715e></span>methodIL.EmitLd8Immediate( <span style=color:#ae81ff>_</span>port);
methodIL.Emit(OpCodes.Ldarg_0);
methodIL.Emit(OpCodes.Ldfld, internals.A);
methodIL.Emit(OpCodes.Callvirt, internals.IOHandlerField.FieldType.GetMethod(<span style=color:#e6db74>&#34;Out&#34;</span>)!); <span style=color:#75715e>// Call Out(port, A) consuming port and A from the execution stack
</span></code></pre></div><p>So the output of this is a freaking <em>massive</em> function with 0xFFFF labels, and on average ~10 IL instructions per 8080 instruction.</p><h3 id=step-4---solve-the-problem-of-dynamic-jumps>Step 4 - Solve the problem of dynamic jumps</h3><p>The above process is entirely sufficient to execute an 8080 in CLR IL EXCEPT for one major problem. Dynamic (runtime) jumps. This issue is mostly easily seen with the <code>PCHL</code> instruction. <code>PCHL</code> literally means &ldquo;put the register pair HL into the program counter&rdquo;, or &ldquo;jump to the address at HL&rdquo;.</p><p>There&rsquo;s no way to statically analyse a ROM and know where that will jump to. So we need to have some way, at runtime, of saying &ldquo;Jump to the IL label with value = X&rdquo;.</p><p>I implemented this with a linear jump table placed at the front of the function. In pseudo code that is roughly:</p><ol><li>Set destination address variable to HL</li><li><code>OpCodes.Br JumpTableStart</code></li></ol><p>The jump table (which is statically generated) then looks like this:</p><ol><li>Load destination address</li><li>Compare to 0x0000</li><li>OpCodes.Brtrue 0x0000</li></ol><p>For every single possible opcode (0xFFFF of them). That&rsquo;s a pretty disgusting solution but I wasn&rsquo;t able to come up with anything better. Presumably an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.switch?view=net-5.0" target=_blank>OpCodes.Switch</a> would be better but it still suffers from the same issue of size bloat. Technically this could be implemented by a binary chop through the 0xFFFF space reducing from <code>O(n)</code> to <code>O(log(n))</code> complexity for each dynamic jump but that would increase the program size so I decided not to.</p><h3 id=step-5---solve-interrupts>Step 5 - Solve interrupts</h3><p>The biggest hurdle to overcome in any static/jit compilation solution to emulation is synchronisation with external peripherals. For some systems that&rsquo;s particularly painful (to get full NES rom compatibility you&rsquo;d need to synchronise every memory read/write!) but for the space invaders ROM we can get away with only synchronising on each instruction.</p><p>In an architectural sense what happens here is that any connected device can &ldquo;notify&rdquo; the CPU on the interrupt line and the CPU will (before the next instruction), clear that line and JMP to one of the RST addresses (0x00, 0x08, 0x10 etc) where it will continue operation.</p><p>To implement that in this recompilation we need to poll for that possible interrupt in between each instruction.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>methodIL.MarkLabel(cpuInternal.ProgramLabels[programCounter]);
                    
<span style=color:#75715e>// Check for interrupts
</span><span style=color:#75715e></span>interruptUtils.PostInstructionEmit(methodIL, cpuInternal, (<span style=color:#66d9ef>ushort</span>)programCounter);
</code></pre></div><p>So we delegate to the owning computer architecture, asking it to inject code into the method which will check for and handle interrupts.</p><p>In the case of space invaders, this piece of code will count down the number of cpu cycles and fire a half screen interrupt after 17066 cycles and a full screen interrupt after another 17066 cycles. <a href=https://github.com/DaveTCode/8080JIT/blob/master/SpaceInvadersJIT/SpaceInvadersInterruptUtils.cs#L21 target=_blank>That code</a> is almost certainly the most complex of all the IL I emit and it needs to appear before every single entry instruction!</p><h2 id=issues>Issues</h2><p>On the whole this wasn&rsquo;t actually <em>that</em> hard to implement. The single biggest issue is that you get exactly <strong>no</strong> help from the runtime at all if you&rsquo;ve written bad IL. I definitely got sick of seeing <code>InvalidProgramException</code> by the end of the project!</p><p>Otherwise, the space invaders system is not hard to implement, the extra shift register hardware is trivial, the interrupts are regular and easy to understand and crucially the rendering pipeline is all of <a href=https://github.com/DaveTCode/8080JIT/blob/master/SpaceInvadersJIT/SpaceInvadersApplication.cs#L112 target=_blank>20 lines of code</a> instead of the exceptionally complex Gameboy/Nes style PPU.</p><h2 id=performance>Performance</h2><p>Obviously there&rsquo;s absolutely NO point in doing this from a performance point of view. Even python running on cpython can cope with emulating an 8080 at full speed, however it&rsquo;s interesting to see what sort of performance it achieved.</p><p>Averaging the time taken for all but the first frame to render resulted in 382fps on a fairly powerful laptop&mldr;which is honestly not very impressive. You&rsquo;d expect to be able to get well over 1000fps running an old system like this.</p><p>The more interesting performance note was that the actual invocation of the <code>Run</code> method delegate took over 1s before actually running any code. That&rsquo;s over 1s for the runtime to JIT my overly long function! That time notably increased when adding the interrupt handling so size of function (or possibly number of label markers) directly affects the JIT speed.</p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/davetcode target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/datyler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/8080/>8080</a></span>
<span><a href=/tags/clr/>clr</a></span>
<span><a href=/tags/csharp/>csharp</a></span>
<span><a href=/tags/emulation/>emulation</a></span>
<span><a href=/tags/rust/>rust</a></span>
<span><a href=/tags/satire/>satire</a></span>
<span><a href=/tags/spaceinvaders/>spaceinvaders</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#8080-architecture>8080 Architecture</a><ul><li><a href=#8080-assembly>8080 Assembly</a></li></ul></li><li><a href=#clr-il-background>CLR IL background</a></li><li><a href=#implementation>Implementation</a><ul><li><a href=#step-1---dynamically-construct-a-class-which-looks-like-the-8080-cpu>Step 1 - Dynamically construct a class which looks like the 8080 CPU</a></li><li><a href=#step-2---hook-in-all-the-external-interfaces>Step 2 - Hook in all the external interfaces</a></li><li><a href=#step-3---recompile-the-rom-to-generate-the-run-function>Step 3 - Recompile the ROM to generate the Run function</a></li><li><a href=#step-4---solve-the-problem-of-dynamic-jumps>Step 4 - Solve the problem of dynamic jumps</a></li><li><a href=#step-5---solve-interrupts>Step 5 - Solve interrupts</a></li></ul></li><li><a href=#issues>Issues</a></li><li><a href=#performance>Performance</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/davetcode target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/datyler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/8080/>8080</a></span>
<span><a href=/tags/clr/>clr</a></span>
<span><a href=/tags/csharp/>csharp</a></span>
<span><a href=/tags/emulation/>emulation</a></span>
<span><a href=/tags/rust/>rust</a></span>
<span><a href=/tags/satire/>satire</a></span>
<span><a href=/tags/spaceinvaders/>spaceinvaders</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><ul><li><a href=#8080-architecture>8080 Architecture</a><ul><li><a href=#8080-assembly>8080 Assembly</a></li></ul></li><li><a href=#clr-il-background>CLR IL background</a></li><li><a href=#implementation>Implementation</a><ul><li><a href=#step-1---dynamically-construct-a-class-which-looks-like-the-8080-cpu>Step 1 - Dynamically construct a class which looks like the 8080 CPU</a></li><li><a href=#step-2---hook-in-all-the-external-interfaces>Step 2 - Hook in all the external interfaces</a></li><li><a href=#step-3---recompile-the-rom-to-generate-the-run-function>Step 3 - Recompile the ROM to generate the Run function</a></li><li><a href=#step-4---solve-the-problem-of-dynamic-jumps>Step 4 - Solve the problem of dynamic jumps</a></li><li><a href=#step-5---solve-interrupts>Step 5 - Solve interrupts</a></li></ul></li><li><a href=#issues>Issues</a></li><li><a href=#performance>Performance</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2020-2021
<a href=https://blog.davetcode.co.uk/>David Tyler</a>
| <a href=https://github.com/davetcode>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script></body></html>