<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>emulation on David Tyler's Blog</title><link>https://blog.davetcode.co.uk/tags/emulation/</link><description>Recent content in emulation on David Tyler's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><lastBuildDate>Sat, 01 May 2021 13:33:09 +0000</lastBuildDate><atom:link href="https://blog.davetcode.co.uk/tags/emulation/index.xml" rel="self" type="application/rss+xml"/><item><title>Bringing emulation into the 21st century</title><link>https://blog.davetcode.co.uk/post/21st-century-emulator/</link><pubDate>Sat, 01 May 2021 13:33:09 +0000</pubDate><guid>https://blog.davetcode.co.uk/post/21st-century-emulator/</guid><description>I&amp;rsquo;m a huge fan of emulation but have become increasingly disillusioned with the lack of ambition shown by those in the emulation community. Whilst the rest of world moves onto massively distributed architectures, emulation is still stuck firmly in the 20th century writing single threaded C++ of all things.
As a modern forward thinking engineer I took it upon myself to start the trend of bringing emulation into the 21st century where we can leverage features like these:
Hot swappable microcode Ability to write different parts in different languages as appropriate Secure by default (mTLS on all function calls) Scalability Fault tolerance This culminated in the implementation of an 8080 microprocessor utilising a truly modern containerised microservices based architecture running on kubernetes with swappable frontends for a CP/M test harness and a full implementation of the original Space Invaders arcade machine.</description></item><item><title>Experiments in 8080 static/jit compilation</title><link>https://blog.davetcode.co.uk/post/jit-8080/</link><pubDate>Fri, 15 Jan 2021 13:33:09 +0000</pubDate><guid>https://blog.davetcode.co.uk/post/jit-8080/</guid><description>I&amp;rsquo;ve spent a lot of spare time over the last few years playing with emulating old computer architectures. I also spend my day job mentoring (and even occasionally writing) C#. This project combines those two areas of interest and asks the question: &amp;ldquo;Is it possible to recompile 8080 assembly into CLR IL&amp;rdquo;
Did it work? Yes! I have successfully built a fully functional Space Invaders emulator with the 8080 cpu core purely implemented in IL.
This blog post covers some of the details of what 8080 assembly looks like, what IL looks like, the process of mapping one to the other and also a fair bit of details about the complications involved.</description></item><item><title>Nes Emulator in Rust</title><link>https://blog.davetcode.co.uk/post/nes-emulator-rust/</link><pubDate>Thu, 10 Dec 2020 10:09:51 +0000</pubDate><guid>https://blog.davetcode.co.uk/post/nes-emulator-rust/</guid><description>Over a period of 2 months in 2020 I intermittently worked on a NES emulator in rust to build a proper opinion of the language (and because it&amp;rsquo;s fun). On the whole it was quite successful, https://github.com/DaveTCode/nes-emulator-rust now exists, has coverage of maybe 80% of the total ROM dumps out there, and passes almost all of the test rom suite.
All achieved with no unsafe, no Rc/Refcell, minimal heap allocations (we don&amp;rsquo;t know how big a Rom is at compile time, it might be 8KB or 256KB) and a small handful of external crates.
This blog post is a write up of my feelings around rust as a language but probably provides some insights into writing an emulator along the way.</description></item></channel></rss>